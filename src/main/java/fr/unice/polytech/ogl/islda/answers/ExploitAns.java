package fr.unice.polytech.ogl.islda.answers;

import fr.unice.polytech.ogl.islda.decisions.GlimpseDec;
import fr.unice.polytech.ogl.islda.decisions.TransformDec;
import fr.unice.polytech.ogl.islda.extras.ExploitExt;
import fr.unice.polytech.ogl.islda.map.Direction;
import fr.unice.polytech.ogl.islda.map.Mapper;
import fr.unice.polytech.ogl.islda.model.Objective;
import fr.unice.polytech.ogl.islda.model.ResourceSec;
import fr.unice.polytech.ogl.islda.model.ResourceSecEnum;
import fr.unice.polytech.ogl.islda.parameters.TransformParameters;
import fr.unice.polytech.ogl.islda.utils.DecisionManager;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Lucas Soumille
 * @version 06/03/15
 */
public class ExploitAns extends Answer {
    private ExploitExt extras;
    private String resource;
    private static final int MIN_FACTOR = 2;

    public ExploitAns(String status, int cost, ExploitExt extras) {
        super(status, cost);
        this.extras = extras;
    }

    @Override
    public void init(Mapper map) {
        map.getCurrentCase().removeResource(resource);
        getContext().increaseObjective(resource, extras.getAmount());
    }

    @Override
    public String nextDecision(DecisionManager decisionManager, Mapper map) {
        if (!decisionManager.isEmpty()) {
            return decisionManager.getFirstDecisionJson();
        }

        boolean transform = checkTransform(decisionManager);

        List<Direction> dirs = map.getDirectionWithGoodBiome(getContext().getObjective());
        if(!dirs.isEmpty()){
            map.move(map.getCaseAround(dirs.get(0),1), decisionManager);
        }

        if (!decisionManager.isEmpty() && !transform) {
            return decisionManager.getFirstDecisionJson();
        }

        dirs = map.getEmptyBiomesDirections();
        if(!dirs.isEmpty()){
            for(Direction dir : dirs){
                decisionManager.addDecisionToQueue(new GlimpseDec(dir,4));
            }
        }

        if (!decisionManager.isEmpty() && !transform) {
            return decisionManager.getFirstDecisionJson();
        }

        map.move(map.getCaseVisitedBiomeEdge(), decisionManager);

        return decisionManager.getFirstDecisionJson();
    }

    /**
     * Check if the transform is useful now
     * @param dm The decision manager if we need to add a transform decision
     * @return true if transform is useful
     */
    public boolean checkTransform(DecisionManager dm) {
        boolean transform = false;
        for (Objective obj : getContext().getObjectivesByLevel(2)) {
            if (obj.canFinishContract(getContext()) && numberTransformAvailable(obj) >= obj.getAmount()) {
                doAllTransform(dm, obj);
                transform = true;
            } else if (obj.canTransform(getContext())) {
                doPartialTransform(dm, obj);
                transform = true;
            }
        }

        return transform;
    }

    /**
     * Add transform case we can create something with what we currently have
     * @param dm The decision manager to add the transform decision
     * @param objToTransform The objectif to transform
     */
    public void doPartialTransform(DecisionManager dm, Objective objToTransform) {
        int wantedAmount = objToTransform.getAmount()-objToTransform.getHarvestedAmount();
        List<Objective> listObj = new ArrayList<>();
        List<ResourceSec> priResources = ResourceSecEnum.getPrimaryList(objToTransform);
        for (ResourceSec priRes : priResources) {
            Objective obj = getContext().getObjective(priRes.getResource());
            if (obj == null) {
                return;
            }
            double maxTransformable = priRes.getAmount() * MIN_FACTOR;
            int harvestedAmount = obj.getHarvestedAmount();
            while (harvestedAmount >= maxTransformable+priRes.getAmount() && maxTransformable < wantedAmount*priRes.getAmount()) {
                maxTransformable += priRes.getAmount();
            }
            int intMaxTransformable = (int) Math.floor(maxTransformable);
            if (intMaxTransformable > harvestedAmount) {
                intMaxTransformable = harvestedAmount;
            }
            int numberMaxTransfo = numberTransformAvailable(objToTransform);
            int priResMax = (int)(Math.floor(numberMaxTransfo*priRes.getAmount()));
            if(intMaxTransformable > priResMax) {
                intMaxTransformable = priResMax;
            }
            listObj.add(new Objective(priRes.getResource(), intMaxTransformable));
            obj.decreaseHarvest(intMaxTransformable);
        }
        if (!listObj.isEmpty()) {
            dm.addDecisionToQueue(new TransformDec(new TransformParameters(listObj)));
        }
    }

    /**
     * Add transform case we can fulfill the contract with what we currently have
     * @param dm The decision manager to add the transform decision
     * @param objToTransform The objectif to transform
     */
    private void doAllTransform(DecisionManager dm, Objective objToTransform) {
        List<Objective> listObj = new ArrayList<>();
        List<ResourceSec> priResources = ResourceSecEnum.getPrimaryList(objToTransform);
        for (ResourceSec priRes : priResources) {
            Objective obj = getContext().getObjective(priRes.getResource());
            if (obj == null) {
                return;
            }
            double factor = 1.1;
            int wantedAmount = (int) (Math.ceil((objToTransform.getAmount()-objToTransform.getHarvestedAmount())*factor*priRes.getAmount()));
            if (wantedAmount > obj.getHarvestedAmount()) {
                wantedAmount = obj.getHarvestedAmount();
            }
            listObj.add(new Objective(priRes.getResource(), wantedAmount));
            obj.decreaseHarvest(wantedAmount);
        }
        dm.addDecisionToQueue(new TransformDec(new TransformParameters(listObj)));
    }

    /**
     * Return the maximum number of transform available thanks to the budget
     * @param obj
     * @return
     */
    public int numberTransformAvailable(Objective obj) {
        int currentBudget = this.getContext().getBudget();
        int budgetToLeave = this.getContext().getMinimumBudget();
        int budgetAvailableTransform = currentBudget - budgetToLeave;
        double factor = ResourceSecEnum.valueOf(obj.getResource()).getCostFactor();
        int nbTransformationAvailable = (int)(Math.floor((budgetAvailableTransform/factor) * this.getContext().getMen()));
        return nbTransformationAvailable;
    }

    @Override
    public ExploitExt getExtras() {
        return extras;
    }

    public void setExtras(ExploitExt extras) {
        this.extras = extras;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ExploitAns)) {
            return false;
        }

        ExploitAns that = (ExploitAns) o;

        return extras.equals(that.extras);
    }

    @Override
    public int hashCode() {
        int result = extras != null ? extras.hashCode() : 0;
        result = 31 * result + (resource != null ? resource.hashCode() : 0);
        return result;
    }

    public void setResource(String resource) {
        this.resource = resource;
    }

    public String getResource() {
        return resource;
    }
}
